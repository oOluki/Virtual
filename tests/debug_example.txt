Q_rsqrt:
    ;; saving register values
    PUSH RB
    PUSH RC
    PUSH RF

    ;; evil bit level hacking (trivial in this case)
    MOV RB RA

    ;; "what the fuck"
    MOVN RC 0
    BSHIFT RB RB RC
    MOVV16 RC6 0x5fe6
    MOVV16 RC4 0xec85
    MOVV16 RC2 0xe7de
    MOVV16 RC  0x30da
    SUB RC RC RB

    ; newton's method iteration
    MOVV RB 1
    MOVV RF 2
    FLOAT RB RB RF
    MULF RB RA RB
    MULF RB RC RB
    MULF RB RC RB
    MOVV RA 3
    MOVV RF 2
    FLOAT RA RA RF
    SUBF RA RA RB
    MULF RA RC RA

    ;; restoring register values and returning
    POP RF
    POP RC
    POP RB
    RET


sqrt:
    PUSH RB
    CALL @Q_rsqrt
    MOVV RB 1
    CASTFU RB RB
    DIVF RA RB RA
    POP RB
    RET

;; gets an uint number through RA and returns if the number is prime or not through the same register
is_prime_ret_false:
    POP RD
    POP RC
    POP RB
    MOVV RA 0
    RET
is_prime_ret_true:
    POP RD
    POP RC
    POP RB
    MOVV RA 1
    RET
is_prime:
    PUSH RB
    PUSH RC
    PUSH RD
    MOV RB RA

    MOVV RC 2
    EQ   RD RB RC
    JMPF RD @is_prime_ret_true
    SMLU RD RB RC
    JMPF RD @is_prime_ret_false

    CASTFU RA RA
    CALL @sqrt
    CASTUF RA RA

    loop:
        DIVU RD RB RA
        MUL  RD RD RA
        EQ   RD RD RB
        JMPF RD @is_prime_ret_false
        DEC  RA 1
        SMLU RD RA RC
    JMPFN RD @loop
    JMP @is_prime_ret_true
%unlabel loop
%unlabel is_prime_ret_true
%unlabel is_prime_ret_false


;; takes a range from RB.as_uint64 to RC.as_uint64 and prints
;; the primes in that range to RA.as_ptr file
primes_ret:
    PUSH RF
    RET
primes:
    POP  RF
    SMLU RD RB RC
    JMPFN RD @primes_ret

    loop:
        MOV RA RB
        CALL @is_prime
        JMPFN RA 2
        PUSH RB
        INC  RB 1
        SMLU RD RB RC
    JMPF RD @loop

    JMP @primes_ret
%unlabel loop
%unlabel primes_ret

exit:
    HALT 0

%start


MOVV RB 1
MOVV RC 100

CALL @primes

MOVV RA 0

loop:
    SMLU   RB RA RSP
    JMPFN  RB @exit
    POP    RC
    DISREG RC R0 R0
JMP @loop

